import numpy as np
import os
import pickle
import matplotlib.pyplot as plt
from mpl_toolkits.axes_grid1 import make_axes_locatable

from utils.utils_ptycho import l2_error

# Specify the overlap ratio and probe amplitude values
overlap_ratio = 0.045454545454545456
probe_amplitude = 100

# Specify the number of pixels to crop before calculating the metrics. Make sure
# that it is equal to the half of the width of the probe.
num_pix_crop = 8

# Path of the folder containing the pickle files
result_path = "./results/overlap_ratio_" + str(overlap_ratio) + "_probe_amplitude_" + str(probe_amplitude) + "/"

# Index of the test example
test_sample_idx = "8"

# Obtain the samples of the proposed method and their mean
ula_poisson_results_path = result_path + test_sample_idx + "_ula_poisson_results.pkl"
with open(ula_poisson_results_path, 'rb') as f:
    ula_samples = pickle.load(f)
    ula_samples = np.array(ula_samples)

# Obtain the true object
ground_truth_path = result_path + test_sample_idx + "_true_object.pkl"
with open(ground_truth_path, 'rb') as f:
    gt_object = pickle.load(f)
    gt_object = gt_object.numpy()
    gt_object = gt_object[:,:,num_pix_crop:-num_pix_crop,num_pix_crop:-num_pix_crop]

# Calculate the error for each sample generated by our method
errors = []
for i in range(ula_samples.shape[0]):
    ula_sample = np.expand_dims(ula_samples[i,:,:,:], 0)
    ula_sample = ula_sample[:,:,num_pix_crop:-num_pix_crop,num_pix_crop:-num_pix_crop]
    error = l2_error(gt_object, ula_sample)
    errors.append(error)

# Plot
iterations = np.arange(1, ula_samples.shape[0] + 1)
plt.figure(figsize = (10, 6))
plt.plot(iterations, errors, marker='o', linestyle='-', color='blue')
plt.xlabel('Iterations (Post Burn-in)')
plt.ylabel('Error')
plt.grid(True, which = 'both', linestyle = '--', color = 'gray', linewidth = 0.5)
plt.savefig("example_reconstruction_performance_vs_iterations.pdf", format='pdf', bbox_inches = 'tight', pad_inches = 0)
plt.show()
